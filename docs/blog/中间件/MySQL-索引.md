# MySQL 索引

---

前言：

MySQL 支持B-Tree 和 Hash、空间数据索引(R-Tree, 还不完整)、 全文索引(更适合做文字匹配)以及三方插件自己的索引方式。
book：《Relational Database Index Design and the Optimizers》

## 基础知识：

### 索引分聚簇索引和非聚簇缩影。索引是B+树结构(InnoDB), MYISAM 是hash。

- 聚簇索引， 一张表只有主键是聚簇索引(没有主键，自增唯一且not null的字段也可以是，都没有就有一个隐藏的)
    - 在叶子节点上保留着下一个页的地址以及这个主键的所有数据。
      优点：
        1. 索引的叶子上存放了行数据，减少了I/O操作。
           缺点：
        2. 如果是内存型的存储引擎，聚簇索引的减少I/O操作的优点就没有了。
        3. 插入速度依赖于插入的顺序，如果不是按照主键顺序插入，最好最好用 OPTIMIZE TABLE [table name] 命令重新组织表。
      > 注： OPTIMIZE TABLE重新组织 table 数据和关联索引数据的物理存储，以减少存储空间并提高访问 table 时的 I/O
      效率。对每个 table 所做的确切更改取决于该 table 使用的storage engine。
        4. 主键值更新可能导致 页分裂， 如果其他页放不下则需要更多的I/O 操作。
- 非聚簇索引，像唯一，聚合等就可能是非聚簇的索引，
    - 在叶子节点上只有索引键和主键值，然后利用主键再去找数据。

### B+ 树的好处。(B+树，多路平衡树，可以是M叉子树)

    1. 范围查询的话更显优势(比较hash来说)。
    2. 每个节点又是用链表的，相连数据获取速度快。
    3. 数据量大时， 可以一次加载一个节点去寻找。

### 数据查询过程

> 经过连接器 -> 语法分析器 -> 优化器 -> 执行器 -> Innodb存储引擎

- 在 Innodb 中，第一次查询时，在内存中的buffer pool中查看有无当前数据，有则查找缓存并返回，无则去加载数据页到buffer pool。
  buffer pool 对应的其他数据结构：(默认数据页16k)
    1. 有一个data链表是当前查询过的数据的描述信息(包含数据的地址/页)，使用LRU算法
    2. 一个free 链表表示buffer pool中空闲的缓存页，可以将数据页加载到该位置。
    3. flush 链表，存放更新的数据，包括删除的。 数据的CRUD都是在缓存中进行的，最后flush到磁盘的。
- 一次只能有一个线程可以获取锁，然后再buffer pool进行更新操作。 因为是内存操作，所以比较快。

## Q&A:

### Hash索引：

案例： 将索引的数据值进行hash操作后，存到数据地址到相应hash的位置。如果hash冲突，在Memory 引擎中是在位置中存储一个链表，将相同hash值的数据放入。

注：innodb会对频繁使用的索引值锁自适应hash索引，这是系统自动完成的，这个功能可以被关闭。
自适应hash索引: 在B树索引基础上，如果一个数据访问频繁，系统会自动给其建立hash索引，以加快查找速度。

优点：

- 查询单条数据非常快。
- 缺点：
- 因为是随机存储的，不能排序。
- 索引中没有存储索引值，而是存数据地址，内存操作也不影响速度。
- 多值索引的话，不支持最左前缀原则。
- hash冲突大时，代价很大。修改冲突时需要遍历链表然后做增删，如果链表很大则很耗时间。

#### tip：

- 思想： 将值唯一化，在索引中就会很快被找到。

如：在Innodb中使用的话，可以将需要索引的值进行hash然后存在表中，然后查询时只要Where xxIndex = crc32(xx) and xx = ?，
这样查找全表记录很快，因为用hash索引的。

### R-Tree: 一般用 PostgreSQL 或者 PostGIS

#### 为什么使用B+Tree：

- B tree：

1. 树内的每个节点都存储数据
2. 叶子节点之间无指针相邻

- B+ tree

1. 数据只出现在叶子节点
2. 所有叶子节点增加了一个链指针

针对上面的B+树和B树的特点，我们做一个总结:

(1)B树的树内存储数据，因此查询单条数据的时候，B树的查询效率不固定，最好的情况是O(1)
。我们可以认为在做单一数据查询的时候，使用B树平均性能更好。但是，由于B树中各节点之间没有指针相邻，因此B树不适合做一些数据遍历操作。

(2)B+树的数据只出现在叶子节点上，因此在查询单条数据的时候，查询速度非常稳定。因此，在做单一数据的查询上，其平均性能并不如B树。但是，B+树的叶子节点上有指针进行相连，因此在做数据遍历的时候，只需要对叶子节点进行遍历即可，这个特性使得B+树非常适合做范围查询。

因此，我们可以做一个推论:没准是Mysql中数据遍历操作比较多，所以用B+树作为索引结构。而Mongodb是做单一查询比较多，数据遍历操作比较少，所以用B树作为索引结构。

#### 那么为什么Mysql做数据遍历操作多？而Mongodb做数据遍历操作少呢？
因为Mysql是关系型数据库，而Mongodb是非关系型数据。

#### 那为什么关系型数据库，做数据遍历操作多？而非关系型数据库做数据遍历操作少呢？
关系型数据库有冗余存储，而且数据一般分布在多个表，可能join多表来查询。
nosql，是文档型，可以把一组关系都存到里面，所以一般值查询单一的就可以。也可以有join操作，叫[lookup](https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/)

聚合索引时，遵守最左前缀原则。 如果有一个索引时 col1_col2_col3, 当 where col1 = 常量 order by col2, col3 desc
才能用到那个索引，如果col1时范围搜索或者order by col2 desc，col3 asc，则不用用到

## 扩展：

数据结构 - 树
### AVL树[适合用于插入删除次数比较少，但查找多的情况]
- 是带有平衡条件的二叉查找树(所有节点的左右子树高度差不超过1)
- 不管我们是执行插入还是删除操作,只要不满足上面的条件,就要通过旋转来保持平衡,而旋转是非常耗时的

### 红黑树(多用于搜索,插入,删除操作多的情况)
- 一种自平衡二叉查找树, 通过对任何一条从根到叶子的路径上各个节点着色的方式的限制,
- 红黑树确保从根到叶子节点的最长路径不会是最短路径的两倍，用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决

### B树(B-树就是B树,-只是一个符号)
- B树(B-Tree)是一种自平衡的树,它是一种多路搜索树（并不是二叉的），能够保证数据有序。
- 同时它还保证了在查找、插入、删除等操作时性能都能保持在O(logn)，
- 为大块数据的读写操作做了优化, 同时它也可以用来描述外部存储(支持对保存在磁盘或者网络上的符号表进行外部查找)
- 添加/删除也是一样的，要考虑添加/删除孩子后，父节点是否还满足子树 k 介于 M/2 和 M 的条件，
- 不满足就得从别的节点拆子树甚至修改相关子树结构来保持平衡。

### B+树
- B+树是B-树的变体，也是一种多路搜索树
- B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；
#### B+的特性：
- 1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的
- 2.不可能在非叶子结点命中
- 3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层
- 4.更适合文件索引系统
- 原因： 增删文件（节点）时，效率更高，因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率
> @See https://www.jianshu.com/p/912357993486

### explain 之 extra 的 filesort:
- 定义: 对于需要排序大量的数据时，mysql采用内存+磁盘的形式来进行排序。 如果内存够就只用内存，不够采用磁盘。
  实现方式：
- 旧： 需两次查询表，一次时主键，一次时回表查需要的字段。然后才进行排序。 会产生大量随机I/O。 在MYISAM中性能更差。
- 新：直接差所有列，然后根据给定列进行排序。这样只有一次顺序IO。但是数据量大时，会很消耗空间。

