# 设计模式

---

`date: 2021-12-16`

## 创建者模式：

 	1. 工厂方法模式
 		- 将一组具有相同特性的对象都继承于他们的抽象，通过工厂类来创建相应的对象，返回的应该是他们的抽象。（针对单一产品类）
 	2. 抽象工厂模式
 	 	- 与工厂方法模式相同，但是对应的是产品族。
 	3. 建造者模式
 	 	- 根据不同的入参构建出不同的结果。
 	4. 原型模式
 	 	- 利用clone特性实现的模式。
 	5. 单例模式
 	 	- 构建出全局唯一实例对象。

## 结构型模式：

 	1. 适配器模式
 	 	- 通过构建一个适配器类，来把转换类型不同的信息转化为统一的。 adaptor（adaptee） => 一种对象
 	2. 桥接模式
 		- 在A类中持有B类的接口，在实例化时候传入B的具体实现， 这个入参称为桥。
 	3. 组合模式
 		- 当有多种组合判断时，可以考虑用决策树来解决，简化调用者使用。
 	4. 装饰器模式
 		- 包装原有类，可以在原有逻辑前后添加逻辑，像Spring的 HandlerInterceptor 一样。
 	5. 外观模式/门面模式
 		- 配置统一入口，在入口处实现特定逻辑。 （接口黑名单）
 	6. 享元模式
 		- 将公用的元素暴露出去，但是要保证一致性。
 	7. 代理模式
 		- 对一个类生成代理类，帮助其完成一系列事情。（mybatis 查询）


## 行为模式:

```
1. 责任链模式
	- 创建一组对象的抽象，对象内部有下一个对象的引用。 （intercepter/ tree node）
2. 命令模式
	- 抽象出命令，执行者，发送命令者，(用多态实现命令，解耦，但类变多)
3. 迭代器模式
	- 按某种顺序操作集合中的元素。可观察 java.util.Iterator
4. 中介者模式
	- 提高资源利用率，在资源包装，提供简单的对外接口. (mybatis sqlSession）
5. 备忘录模式
	- 在不破坏原有类基础上增加回退功能而产生的一个设计模式。
6. 观察者模式
	- 由一个动作而引发的其他事件(异步最佳)。 如MQ的应用。
7. 状态模式
	- 将一个对象可能出现的所有状态单独处理，抽象出一个对象接口。 (开闭，单一，易扩展)
8. 策略模式
	- 为简化 if/else， 剥离抽象，分类实现具体。
9. 模板模式
	- 抽象一个类，类内包含了子类共有的行为， 子类可自定义实现，但是行为时一致的。 多态的实现。
10. 访问者模式
	- 不同对象访问不同的对象，返回不同东西。有点像策略模式。访问者要声明访问不同对象时需要显示的东西。
```



<设计模式，优雅在于单一开闭，在于可扩展性。缺点在于类多了很多。>

<应用:  剥离抽象对象，具体对象实现抽象对象，外界应用时可以传入具体的实现类。或者用一个`map<Type,AbstractObject> ` 让外界调用。 > 


---

基于[小傅哥](http://bugstack.cn)的《重学Java设计模式》总结。 [在用的时候切记思考是否过度设计了。]